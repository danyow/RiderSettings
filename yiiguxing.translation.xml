<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="abstract" />
      <item value="each Marked" />
      <item value="foreach Marked" />
      <item value="wait Times" />
      <item value="分析" />
      <item value="不重复的" />
      <item value="初始化中" />
      <item value="finally" />
      <item value="依据数据更新视图" />
      <item value="更新视图内的数据" />
      <item value="Utilities" />
      <item value="常用的" />
      <item value="Utilis" />
      <item value="The transform relative to the entity's parent." />
      <item value="Butterfly Particle Authoring" />
      <item value="this overload exists here with the sole purpose of being able to give the user a not-totally-horrible&#10;        experience when they try to use an unsupported lambda signature. When this happens, the C compiler&#10;        will go through its overload resolution, take the first candidate, and explain the user why the users&#10;        lambda is incompatible with that first candidates' parametertype.  We put this method here, instead&#10;        of with the other .ForEach overloads, to make sure this is the overload that the c compiler will pick&#10;        when generating its compiler error.  If we didn't do that, it might pick a completely unrelated .ForEach&#10;        extension method, like the one for IJobChunk.&#10;        &#10;        The only communication channel we have to the user to guide them to figuring out what their problem is&#10;        is the name of the expected delegate type, as the c compiler will put that in its compiler error message.&#10;        so we take this very unconventional approach here of encoding a message for the user in that type name,&#10;        that is easily googlable, so they will end up at a documentation page that describes why some lambda&#10;        signatures are compatible, and why some aren't, and what to do about that.&#10;        &#10;        the reason the delegate type is in the global namespace, is that it makes for a cleaner error message&#10;        it's marked with an attribute to prevent it from showing up in intellisense." />
      <item value="Invalid For Each Signature See For Each Documentation For Rules And Restrictions" />
      <item value="Taylor Inv Sqrt" />
      <item value="triangle Extent" />
      <item value="The mathematical constant pi. Approximately 3.14" />
      <item value="Elapsed Time" />
      <item value="Amplitude" />
      <item value="Simplex noise." />
      <item value="cast Shadows" />
      <item value="template Mesh" />
      <item value="effect Rate" />
      <item value="Expiration" />
      <item value="Reconstruction" />
      <item value="Particle Reconstruction System Base" />
      <item value="Get Instance" />
      <item value="Concrete Id Binder Generic" />
      <item value="bind Statement" />
      <item value="Attempted to start a binding during a binding finalizer.  This is not allowed, since binding finalizers should directly use AddProvider instead, to allow for bindings to be inherited properly without duplicates" />
      <item value="_is Finalizing Binding" />
      <item value="Create Internal" />
      <item value="         Generate the full list of size and speeds so that we can maintain an approximate average&#10;         this way we don't get wildly different difficulties each time the game is run&#10;         For example, if we just chose speed randomly each time we spawned an asteroid, in some&#10;         cases that might result in the first set of asteroids all going at max speed, or min speed" />
      <item value="Asteroid" />
      <item value="Placeholder Factory" />
      <item value="Preserve Attribute" />
      <item value="Bind Instance" />
      <item value="    We prefer to use ScriptableObjectInstaller for installers that contain game settings&#10;     There's no reason why you couldn't use a MonoInstaller here instead, however&#10;     using ScriptableObjectInstaller has advantages here that make it nice for settings:&#10;    &#10;     1) You can change these values at runtime and have those changes persist across play&#10;        sessions.  If it was a MonoInstaller then any changes would be lost when you hit stop&#10;     2) You can easily create multiple ScriptableObject instances of this installer to test&#10;        different customizations to settings.  For example, you might have different instances&#10;        for each difficulty mode of your game, such as &quot;Easy&quot;, &quot;Hard&quot;, etc.&#10;     3) If your settings are associated with a game object composition root, then using&#10;        ScriptableObjectInstaller can be easier since there will only ever be one definitive&#10;        instance for each setting.  Otherwise, you'd have to change the settings for each game&#10;        object composition root separately at runtime" />
      <item value="Scriptable Object Installer" />
      <item value="Inject Optional" />
      <item value="    We could just add [Inject] to the field declarations but&#10;         it's often better practice to use PostInject methods&#10;         Note that we can't use Constructors here because this is&#10;         a MonoBehaviour" />
      <item value="Particle" />
      <item value="通用步骤" />
      <item value="Common Step" />
      <item value="Vertices" />
      <item value="Axis vectors" />
      <item value="Flapping" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="345" />
        <entry key="ENGLISH" value="346" />
        <entry key="FRENCH" value="1" />
        <entry key="LITHUANIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1668274134977" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20210603000851873" />
      </app-key>
    </option>
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1680699081271" />
  </component>
  <component name="Translation.Settings">
    <option name="translator" value="MICROSOFT" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Changes a TO tween into a FROM tween: sets the current target's position as the tween's endValue then immediately sends the target to the previously set endValue." />
      <item value="Generate Tween Internal" />
      <item value="Animation Sequencer" />
      <item value="requires Reset" />
      <item value="snapping" />
      <item value="ABS Animation Component" />
      <item value="Is Assignable From" />
      <item value="Knob" />
      <item value="Achievement" />
      <item value="Idents" />
      <item value="Preserve" />
      <item value="Del Here" />
      <item value="LEOECSLITE NO SANITIZE CHECKS" />
      <item value="Поле должно быть проинициализировано в инспекторе средствами редактора" />
      <item value="Ecs Ugui Emitter" />
      <item value="_ugui Emitter" />
      <item value="Поле должно быть проинициализировано в инспекторе средствами редактора Unity." />
      <item value="Emitter system for uGui events to ECS world." />
      <item value="Singleton" />
      <item value="Publish Async" />
      <item value="include Platforms" />
      <item value="Un Order Multi Map" />
      <item value="数据结构" />
      <item value="Proto Object" />
      <item value="Dispose Object" />
      <item value="Friend Of" />
      <item value="Debug Updater" />
      <item value="Win Period" />
      <item value="I Serialization Callback Receiver" />
      <item value="Exterior Set Zone Nav" />
      <item value="Distinct" />
      <item value="Trim Excess" />
      <item value="define Symbols" />
      <item value="不支持的" />
      <item value="unsupported" />
      <item value="Supported Gradle Commands" />
      <item value="Support Gradle Commands" />
      <item value="Get Scripting Define Symbols For Group" />
      <item value="_center Style" />
      <item value="un Valid" />
      <item value="失败" />
      <item value="文档" />
      <item value="MenuCommand is the only optional supported parameter." />
      <item value="from from" />
      <item value="form" />
      <item value="form Rim" />
      <item value="Disable Load Asset By File Name With Extension" />
      <item value="Disable Load Asset By File Name" />
      <item value="Chunk Based Compression" />
      <item value="dependence" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="53" />
        <entry key="ENGLISH" value="54" />
        <entry key="RUSSIAN" value="2" />
      </map>
    </option>
  </component>
</application>