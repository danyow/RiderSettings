<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Check Write And Throw" />
      <item value="operator" />
      <item value="implicit" />
      <item value="Copy of the AtomicSafetyHandle from the full NativeCounter. The dispose sentinel is not copied since this inner struct does not own the memory and is not responsible for freeing it" />
      <item value="Copy of the pointer from the full NativeCounter" />
      <item value="Native Disable Unsafe Ptr Restriction" />
      <item value="Parallel For" />
      <item value=" This attribute is what makes it possible to use NativeCounter.Concurrent in a ParallelFor job" />
      <item value="Native Container Is Atomic Write Only" />
      <item value="Native Item" />
      <item value="Native Thing" />
      <item value=" Let the dispose sentinel know that the data has been freed so it does not report any memory leaks" />
      <item value="Dispose" />
      <item value="Verify that the caller has write permission on this data. This is the race condition protection, without these checks the AtomicSafetyHandle is useless" />
      <item value=" Verify that the caller has read permission on this data.&#10;             This is the race condition protection, without these checks the AtomicSafetyHandle is useless" />
      <item value=" Verify that the caller has write permission on this data.&#10;         This is the race condition protection, without these checks the AtomicSafetyHandle is useless" />
      <item value="Increment" />
      <item value="data" />
      <item value="uninitialized data" />
      <item value="Initialize the count to 0 to avoid uninitialized data" />
      <item value="Atomic Safety Handle" />
      <item value="Create a dispose sentinel to track memory leaks. This also creates the AtomicSafetyHandle" />
      <item value=" This check is redundant since we always use an int which is blittable.&#10;         It is here as an example of how to check for type correctness for generic types." />
      <item value=" Allocate native memory for a single integer" />
      <item value="{0} used in NativeQueue&lt;{0}&gt; must be blittable" />
      <item value="used in NativeQueue&lt;{0}&gt; must be blittable" />
      <item value="Keep track of where the memory for this was allocated" />
      <item value=" The dispose sentinel tracks memory leaks. It is a managed type so it is cleared to null when scheduling a job&#10;     The job cannot dispose the container, and no one else can dispose it until the job has run so it is ok to not pass it along&#10;     This attribute is required, without it this native container cannot be passed to a job since that would give the job access to a managed object" />
      <item value="Native Set Class Type To Null On Schedule" />
      <item value="ENABLE UNITY COLLECTIONS CHECKS" />
      <item value="The actual pointer to the allocated count needs to have restrictions relaxed so jobs can be schedled with this container" />
      <item value="Sequential" />
      <item value="因子" />
      <item value="facet" />
      <item value="With Native Disable Parallel For Restriction" />
      <item value="The total cumulative elapsed time in seconds." />
      <item value="Set Shared Component Filter" />
      <item value="With Store Entity Query In Field" />
      <item value="Allocation list" />
      <item value="Populate fly entities." />
      <item value="used just for dependency tracking" />
      <item value="Update After" />
      <item value="Fly Component" />
      <item value="A 2D rectangular mask that allows for clipping  masking of areas outside the mask." />
      <item value="         How it works:&#10;        &#10;         SoftMask overrides Shader used by child elements. To do it, SoftMask spawns invisible &#10;         SoftMaskable components on them on the fly. SoftMaskable implements IMaterialOverride,&#10;         which allows it to override the shader that performs actual rendering. Use of&#10;         IMaterialOverride is transparent to the user: a material assigned to Graphic in the &#10;         inspector is left untouched.&#10;        &#10;         Management of SoftMaskables is fully automated. SoftMaskables are kept on the child&#10;         objects while any SoftMask parent present. When something changes and SoftMask parent&#10;         no longer exists, SoftMaskable is destroyed automatically. So, a user of SoftMask&#10;         doesn't have to worry about any component changes in the hierarchy.&#10;        &#10;         The replacement shader samples the mask texture and multiply the resulted color &#10;         accordingly. SoftMask has the predefined replacement for Unity's default UI shader &#10;         (and its ETC1-version in Unity 5.4+). So, when SoftMask 'sees' a material that uses a&#10;         known shader, it overrides shader by the predefined one. If SoftMask encounters a&#10;         material with an unknown shader, it can't do anything reasonable (because it doesn't know&#10;         what that shader should do). In such a case, SoftMask will not work and a warning will&#10;&#9;&#9; be displayed in Console. If you want SoftMask to work with a custom shader, you can&#10;&#9;&#9; manually add support to this shader. For reference how to do it, see&#10;&#9;&#9; CustomWithSoftMask.shader from included samples.&#10;        &#10;         All replacements are cached in SoftMask instances. By default Unity draws UI with a&#10;         very small number of material instances (they are spawned one per maskingclipping layer),&#10;         so, SoftMask creates a relatively small number of overrides." />
      <item value="Compiled" />
      <item value="Ignore Case" />
      <item value=" TODO: provide an implementation of Unity.Debug that does not rely on UnityEngine and modernizes this API&#10;     (for now it's just here for easier compatibility and fwd migration)" />
      <item value="Debug" />
      <item value="错误" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="175" />
        <entry key="ENGLISH" value="176" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660521227146" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
  </component>
</application>