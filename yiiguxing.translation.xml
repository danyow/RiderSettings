<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="abstract" />
      <item value="each Marked" />
      <item value="foreach Marked" />
      <item value="wait Times" />
      <item value="分析" />
      <item value="不重复的" />
      <item value="初始化中" />
      <item value="finally" />
      <item value="依据数据更新视图" />
      <item value="更新视图内的数据" />
      <item value="Utilities" />
      <item value="常用的" />
      <item value="Utilis" />
      <item value="The transform relative to the entity's parent." />
      <item value="Butterfly Particle Authoring" />
      <item value="this overload exists here with the sole purpose of being able to give the user a not-totally-horrible&#10;        experience when they try to use an unsupported lambda signature. When this happens, the C compiler&#10;        will go through its overload resolution, take the first candidate, and explain the user why the users&#10;        lambda is incompatible with that first candidates' parametertype.  We put this method here, instead&#10;        of with the other .ForEach overloads, to make sure this is the overload that the c compiler will pick&#10;        when generating its compiler error.  If we didn't do that, it might pick a completely unrelated .ForEach&#10;        extension method, like the one for IJobChunk.&#10;        &#10;        The only communication channel we have to the user to guide them to figuring out what their problem is&#10;        is the name of the expected delegate type, as the c compiler will put that in its compiler error message.&#10;        so we take this very unconventional approach here of encoding a message for the user in that type name,&#10;        that is easily googlable, so they will end up at a documentation page that describes why some lambda&#10;        signatures are compatible, and why some aren't, and what to do about that.&#10;        &#10;        the reason the delegate type is in the global namespace, is that it makes for a cleaner error message&#10;        it's marked with an attribute to prevent it from showing up in intellisense." />
      <item value="Invalid For Each Signature See For Each Documentation For Rules And Restrictions" />
      <item value="Taylor Inv Sqrt" />
      <item value="triangle Extent" />
      <item value="The mathematical constant pi. Approximately 3.14" />
      <item value="Elapsed Time" />
      <item value="Amplitude" />
      <item value="Simplex noise." />
      <item value="cast Shadows" />
      <item value="template Mesh" />
      <item value="effect Rate" />
      <item value="Expiration" />
      <item value="Reconstruction" />
      <item value="Particle Reconstruction System Base" />
      <item value="Get Instance" />
      <item value="Concrete Id Binder Generic" />
      <item value="bind Statement" />
      <item value="Attempted to start a binding during a binding finalizer.  This is not allowed, since binding finalizers should directly use AddProvider instead, to allow for bindings to be inherited properly without duplicates" />
      <item value="_is Finalizing Binding" />
      <item value="Create Internal" />
      <item value="         Generate the full list of size and speeds so that we can maintain an approximate average&#10;         this way we don't get wildly different difficulties each time the game is run&#10;         For example, if we just chose speed randomly each time we spawned an asteroid, in some&#10;         cases that might result in the first set of asteroids all going at max speed, or min speed" />
      <item value="Asteroid" />
      <item value="Placeholder Factory" />
      <item value="Preserve Attribute" />
      <item value="Bind Instance" />
      <item value="    We prefer to use ScriptableObjectInstaller for installers that contain game settings&#10;     There's no reason why you couldn't use a MonoInstaller here instead, however&#10;     using ScriptableObjectInstaller has advantages here that make it nice for settings:&#10;    &#10;     1) You can change these values at runtime and have those changes persist across play&#10;        sessions.  If it was a MonoInstaller then any changes would be lost when you hit stop&#10;     2) You can easily create multiple ScriptableObject instances of this installer to test&#10;        different customizations to settings.  For example, you might have different instances&#10;        for each difficulty mode of your game, such as &quot;Easy&quot;, &quot;Hard&quot;, etc.&#10;     3) If your settings are associated with a game object composition root, then using&#10;        ScriptableObjectInstaller can be easier since there will only ever be one definitive&#10;        instance for each setting.  Otherwise, you'd have to change the settings for each game&#10;        object composition root separately at runtime" />
      <item value="Scriptable Object Installer" />
      <item value="Inject Optional" />
      <item value="    We could just add [Inject] to the field declarations but&#10;         it's often better practice to use PostInject methods&#10;         Note that we can't use Constructors here because this is&#10;         a MonoBehaviour" />
      <item value="Particle" />
      <item value="通用步骤" />
      <item value="Common Step" />
      <item value="Vertices" />
      <item value="Axis vectors" />
      <item value="Flapping" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="345" />
        <entry key="ENGLISH" value="346" />
        <entry key="FRENCH" value="1" />
        <entry key="LITHUANIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1668274134977" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20210603000851873" />
      </app-key>
    </option>
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1691580380235" />
  </component>
  <component name="Translation.Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20210603000851873" />
      </app-key>
    </option>
    <option name="primaryLanguage" value="CHINESE" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Require Implementors" />
      <item value="inherit" />
      <item value="lazy Load" />
      <item value="Before" />
      <item value="destroy Before Create" />
      <item value="Weak Singleton Mono" />
      <item value="celebration Idle Timer" />
      <item value="leaderboard Timer" />
      <item value="intro Race Timer" />
      <item value="Race" />
      <item value="Race Bootstrap Authoring" />
      <item value="Bootstrap A" />
      <item value="Track Rotation" />
      <item value="track Position" />
      <item value="Tags each spawn point data" />
      <item value="I Buffer Element Data" />
      <item value="Stores the limits of the level in AABB format." />
      <item value="如果当前没有按钮被选中，那么选中第一个按钮" />
      <item value="Focus on the first Car Skin Button" />
      <item value="Access the player's parameters in the race." />
      <item value="Wheel Spring 0" />
      <item value="is Steering" />
      <item value="wheel Spring 0" />
      <item value="vehicle Chassis" />
      <item value="chassis" />
      <item value="Anti Roll Bar" />
      <item value="Authoring" />
      <item value="vehicle Authoring" />
      <item value="has Hit" />
      <item value="surface Friction" />
      <item value="Stores all hit collision data for Wheels." />
      <item value="steer Amount" />
      <item value="drive Amount" />
      <item value="rear Track" />
      <item value="Calculate Steering Angle" />
      <item value="grip Factor" />
      <item value="rotation Angle" />
      <item value="drive Torque" />
      <item value="Stores wheel data such as, visuals, rotation, size..." />
      <item value="Smoothing method as clamp or interpolateextrapolate.Meaning the value can be applied from a snapshot as interpolatedextrapolated or unmodified directly(clamped)." />
      <item value="Quantized or unquantized. Where quantized means a float value is sent as an int with a certain multiplication factor which sets the precision (12.456789 can be sent as 12345 with a quantization factor of 1000)." />
      <item value="Stores data for the chassis and physics forces." />
      <item value="Calculate anti-roll bar and apply correction forces to reduce body roll" />
      <item value="Creates the animation curve for drive torque curve." />
      <item value="sample T" />
      <item value="interpolation" />
      <item value="Find index and interpolation value in the array" />
      <item value="Loops time value between 0...1" />
      <item value="stiffness" />
      <item value="wheels Base" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="326" />
        <entry key="DANISH" value="1" />
        <entry key="ENGLISH" value="327" />
        <entry key="FRENCH" value="2" />
        <entry key="GERMAN" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="PORTUGUESE_BRAZILIAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="RUSSIAN" value="2" />
      </map>
    </option>
  </component>
</application>