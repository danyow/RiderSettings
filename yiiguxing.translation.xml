<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Simplex noise." />
      <item value="cast Shadows" />
      <item value="template Mesh" />
      <item value="effect Rate" />
      <item value="Expiration" />
      <item value="Reconstruction" />
      <item value="Particle Reconstruction System Base" />
      <item value="Get Instance" />
      <item value="Concrete Id Binder Generic" />
      <item value="bind Statement" />
      <item value="Attempted to start a binding during a binding finalizer.  This is not allowed, since binding finalizers should directly use AddProvider instead, to allow for bindings to be inherited properly without duplicates" />
      <item value="_is Finalizing Binding" />
      <item value="Create Internal" />
      <item value="         Generate the full list of size and speeds so that we can maintain an approximate average&#10;         this way we don't get wildly different difficulties each time the game is run&#10;         For example, if we just chose speed randomly each time we spawned an asteroid, in some&#10;         cases that might result in the first set of asteroids all going at max speed, or min speed" />
      <item value="Asteroid" />
      <item value="Placeholder Factory" />
      <item value="Preserve Attribute" />
      <item value="Bind Instance" />
      <item value="    We prefer to use ScriptableObjectInstaller for installers that contain game settings&#10;     There's no reason why you couldn't use a MonoInstaller here instead, however&#10;     using ScriptableObjectInstaller has advantages here that make it nice for settings:&#10;    &#10;     1) You can change these values at runtime and have those changes persist across play&#10;        sessions.  If it was a MonoInstaller then any changes would be lost when you hit stop&#10;     2) You can easily create multiple ScriptableObject instances of this installer to test&#10;        different customizations to settings.  For example, you might have different instances&#10;        for each difficulty mode of your game, such as &quot;Easy&quot;, &quot;Hard&quot;, etc.&#10;     3) If your settings are associated with a game object composition root, then using&#10;        ScriptableObjectInstaller can be easier since there will only ever be one definitive&#10;        instance for each setting.  Otherwise, you'd have to change the settings for each game&#10;        object composition root separately at runtime" />
      <item value="Scriptable Object Installer" />
      <item value="Inject Optional" />
      <item value="    We could just add [Inject] to the field declarations but&#10;         it's often better practice to use PostInject methods&#10;         Note that we can't use Constructors here because this is&#10;         a MonoBehaviour" />
      <item value="Particle" />
      <item value="通用步骤" />
      <item value="Common Step" />
      <item value="Vertices" />
      <item value="Axis vectors" />
      <item value="Flapping" />
      <item value="Look-at matrix from velocity" />
      <item value="Vertex output" />
      <item value="Vertex positions" />
      <item value="Random rotation" />
      <item value="Scaling with simple lerp" />
      <item value="Used to give IDs to particles." />
      <item value="Butterfly Particle Reconstruction System" />
      <item value="Get All Unique Shared Component Data" />
      <item value="Add Job Handle For Producer" />
      <item value="        Tweaks on class modifiers" />
      <item value=" Create an array of clones as putting a clone on each triangle." />
      <item value="Initialize the default entity table." />
      <item value="Cleanup Default Entity Table" />
      <item value="Select Random Default Entity" />
      <item value="Normalize Default Entity Weights" />
      <item value="variant" />
      <item value="Default Entity Entry" />
      <item value="  This table is used to create particle entities with a weighted&#10;         random distribution of particle types. It stores selection weights&#10;         and default entities that allows creating entities with instancing.&#10;" />
      <item value="Default entity table" />
      <item value="Get Weight" />
      <item value=" We want this renderer object disposed at the end of world." />
      <item value="Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="327" />
        <entry key="ENGLISH" value="328" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1663628979587" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
  </component>
</application>