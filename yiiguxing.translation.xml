<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="abstract" />
      <item value="each Marked" />
      <item value="foreach Marked" />
      <item value="wait Times" />
      <item value="分析" />
      <item value="不重复的" />
      <item value="初始化中" />
      <item value="finally" />
      <item value="依据数据更新视图" />
      <item value="更新视图内的数据" />
      <item value="Utilities" />
      <item value="常用的" />
      <item value="Utilis" />
      <item value="The transform relative to the entity's parent." />
      <item value="Butterfly Particle Authoring" />
      <item value="this overload exists here with the sole purpose of being able to give the user a not-totally-horrible&#10;        experience when they try to use an unsupported lambda signature. When this happens, the C compiler&#10;        will go through its overload resolution, take the first candidate, and explain the user why the users&#10;        lambda is incompatible with that first candidates' parametertype.  We put this method here, instead&#10;        of with the other .ForEach overloads, to make sure this is the overload that the c compiler will pick&#10;        when generating its compiler error.  If we didn't do that, it might pick a completely unrelated .ForEach&#10;        extension method, like the one for IJobChunk.&#10;        &#10;        The only communication channel we have to the user to guide them to figuring out what their problem is&#10;        is the name of the expected delegate type, as the c compiler will put that in its compiler error message.&#10;        so we take this very unconventional approach here of encoding a message for the user in that type name,&#10;        that is easily googlable, so they will end up at a documentation page that describes why some lambda&#10;        signatures are compatible, and why some aren't, and what to do about that.&#10;        &#10;        the reason the delegate type is in the global namespace, is that it makes for a cleaner error message&#10;        it's marked with an attribute to prevent it from showing up in intellisense." />
      <item value="Invalid For Each Signature See For Each Documentation For Rules And Restrictions" />
      <item value="Taylor Inv Sqrt" />
      <item value="triangle Extent" />
      <item value="The mathematical constant pi. Approximately 3.14" />
      <item value="Elapsed Time" />
      <item value="Amplitude" />
      <item value="Simplex noise." />
      <item value="cast Shadows" />
      <item value="template Mesh" />
      <item value="effect Rate" />
      <item value="Expiration" />
      <item value="Reconstruction" />
      <item value="Particle Reconstruction System Base" />
      <item value="Get Instance" />
      <item value="Concrete Id Binder Generic" />
      <item value="bind Statement" />
      <item value="Attempted to start a binding during a binding finalizer.  This is not allowed, since binding finalizers should directly use AddProvider instead, to allow for bindings to be inherited properly without duplicates" />
      <item value="_is Finalizing Binding" />
      <item value="Create Internal" />
      <item value="         Generate the full list of size and speeds so that we can maintain an approximate average&#10;         this way we don't get wildly different difficulties each time the game is run&#10;         For example, if we just chose speed randomly each time we spawned an asteroid, in some&#10;         cases that might result in the first set of asteroids all going at max speed, or min speed" />
      <item value="Asteroid" />
      <item value="Placeholder Factory" />
      <item value="Preserve Attribute" />
      <item value="Bind Instance" />
      <item value="    We prefer to use ScriptableObjectInstaller for installers that contain game settings&#10;     There's no reason why you couldn't use a MonoInstaller here instead, however&#10;     using ScriptableObjectInstaller has advantages here that make it nice for settings:&#10;    &#10;     1) You can change these values at runtime and have those changes persist across play&#10;        sessions.  If it was a MonoInstaller then any changes would be lost when you hit stop&#10;     2) You can easily create multiple ScriptableObject instances of this installer to test&#10;        different customizations to settings.  For example, you might have different instances&#10;        for each difficulty mode of your game, such as &quot;Easy&quot;, &quot;Hard&quot;, etc.&#10;     3) If your settings are associated with a game object composition root, then using&#10;        ScriptableObjectInstaller can be easier since there will only ever be one definitive&#10;        instance for each setting.  Otherwise, you'd have to change the settings for each game&#10;        object composition root separately at runtime" />
      <item value="Scriptable Object Installer" />
      <item value="Inject Optional" />
      <item value="    We could just add [Inject] to the field declarations but&#10;         it's often better practice to use PostInject methods&#10;         Note that we can't use Constructors here because this is&#10;         a MonoBehaviour" />
      <item value="Particle" />
      <item value="通用步骤" />
      <item value="Common Step" />
      <item value="Vertices" />
      <item value="Axis vectors" />
      <item value="Flapping" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="345" />
        <entry key="ENGLISH" value="346" />
        <entry key="FRENCH" value="1" />
        <entry key="LITHUANIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1668274134977" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20210603000851873" />
      </app-key>
    </option>
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1681131712495" />
  </component>
  <component name="Translation.Settings">
    <option name="translator" value="MICROSOFT" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="开火" />
      <item value="Utility" />
      <item value="jumpable Ground" />
      <item value="生成动态" />
      <item value="switch" />
      <item value="toggle" />
      <item value="tog Handle" />
      <item value="is Validate Function" />
      <item value="selector" />
      <item value="Cell At Index In Table View Did Skip Selected" />
      <item value="Did Skip Selected" />
      <item value="Did Unselected" />
      <item value="On Did Unselected" />
      <item value="Recycle When Disappeared" />
      <item value="Rearrange Cell" />
      <item value="_is Reaching Topmost Or Rightmost" />
      <item value="Inertia" />
      <item value="Scalar For Upper Margin In Table View" />
      <item value="scalar" />
      <item value="Scalar" />
      <item value="Scalar For Cell In Table View" />
      <item value="Base behaviour that has protected implementations of Unity lifecycle functions." />
      <item value="Tag for distinguishing table view." />
      <item value="k Default Reachable Edge Tolerance" />
      <item value="UI Table View Cell Life Cycle" />
      <item value="Reachable" />
      <item value="Find Property Relative" />
      <item value="InvalidOperationException: Attempting to set the managed reference value on a SerializedProperty that is set to a 'SequenceConfig'" />
      <item value="换行" />
      <item value="Playback" />
      <item value="Flexible Space" />
      <item value="Redraw any inspectors that shows this editor." />
      <item value="that instructs Unity to serialize a field as a reference instead of as a value." />
      <item value="A that instructs Unity to serialize a field as a reference instead of as a value." />
      <item value="Reorderable List" />
      <item value="Used by the CustomEditor so it knows when to reset to the defaults." />
      <item value="Work around a Unity bug where updating the colour does not cause any visual change outside of PlayMode." />
      <item value="tween.SetRelative() does not work for From variant of &quot;Move To Anchored Position&quot;, it must be set here instead. Not sure if this is a bug in DOTween or expected behaviour..." />
      <item value="If applied to Sequences eases the whole sequence animation" />
      <item value="Sets the ease of the tween." />
      <item value="Changes a TO tween into a FROM tween: sets the current target's position as the tween's endValue then immediately sends the target to the previously set endValue." />
      <item value="Generate Tween Internal" />
      <item value="Animation Sequencer" />
      <item value="requires Reset" />
      <item value="snapping" />
      <item value="ABS Animation Component" />
      <item value="Is Assignable From" />
      <item value="Knob" />
      <item value="Achievement" />
      <item value="Idents" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="92" />
        <entry key="DANISH" value="1" />
        <entry key="ENGLISH" value="92" />
        <entry key="RUSSIAN" value="2" />
      </map>
    </option>
  </component>
</application>