<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1654" />
    <option name="newTranslationDialogY" value="627" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Create Internal" />
      <item value="         Generate the full list of size and speeds so that we can maintain an approximate average&#10;         this way we don't get wildly different difficulties each time the game is run&#10;         For example, if we just chose speed randomly each time we spawned an asteroid, in some&#10;         cases that might result in the first set of asteroids all going at max speed, or min speed" />
      <item value="Asteroid" />
      <item value="Placeholder Factory" />
      <item value="Preserve Attribute" />
      <item value="Bind Instance" />
      <item value="    We prefer to use ScriptableObjectInstaller for installers that contain game settings&#10;     There's no reason why you couldn't use a MonoInstaller here instead, however&#10;     using ScriptableObjectInstaller has advantages here that make it nice for settings:&#10;    &#10;     1) You can change these values at runtime and have those changes persist across play&#10;        sessions.  If it was a MonoInstaller then any changes would be lost when you hit stop&#10;     2) You can easily create multiple ScriptableObject instances of this installer to test&#10;        different customizations to settings.  For example, you might have different instances&#10;        for each difficulty mode of your game, such as &quot;Easy&quot;, &quot;Hard&quot;, etc.&#10;     3) If your settings are associated with a game object composition root, then using&#10;        ScriptableObjectInstaller can be easier since there will only ever be one definitive&#10;        instance for each setting.  Otherwise, you'd have to change the settings for each game&#10;        object composition root separately at runtime" />
      <item value="Scriptable Object Installer" />
      <item value="Inject Optional" />
      <item value="    We could just add [Inject] to the field declarations but&#10;         it's often better practice to use PostInject methods&#10;         Note that we can't use Constructors here because this is&#10;         a MonoBehaviour" />
      <item value="Particle" />
      <item value="通用步骤" />
      <item value="Common Step" />
      <item value="Vertices" />
      <item value="Axis vectors" />
      <item value="Flapping" />
      <item value="Look-at matrix from velocity" />
      <item value="Vertex output" />
      <item value="Vertex positions" />
      <item value="Random rotation" />
      <item value="Scaling with simple lerp" />
      <item value="Used to give IDs to particles." />
      <item value="Butterfly Particle Reconstruction System" />
      <item value="Get All Unique Shared Component Data" />
      <item value="Add Job Handle For Producer" />
      <item value="        Tweaks on class modifiers" />
      <item value=" Create an array of clones as putting a clone on each triangle." />
      <item value="Initialize the default entity table." />
      <item value="Cleanup Default Entity Table" />
      <item value="Select Random Default Entity" />
      <item value="Normalize Default Entity Weights" />
      <item value="variant" />
      <item value="Default Entity Entry" />
      <item value="  This table is used to create particle entities with a weighted&#10;         random distribution of particle types. It stores selection weights&#10;         and default entities that allows creating entities with instancing.&#10;" />
      <item value="Default entity table" />
      <item value="Get Weight" />
      <item value=" We want this renderer object disposed at the end of world." />
      <item value="Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS." />
      <item value="A NativeArray exposes a buffer of native memory to managed code, making it possible to share data between managed and native without marshalling costs." />
      <item value="Pointer to an underlying graphics API texture resource.&lt;" />
      <item value="Reset the triangle counter for the next frame." />
      <item value="Set the initial data." />
      <item value="Destroy the temporary objects." />
      <item value="Create an array of clones as putting a clone on each triangle." />
      <item value="Create the default entities." />
      <item value=" We want to do entity instantiation in parallel with the jobs,&#10;             so let the jobs kick in immediately." />
      <item value="Create a renderer for this group." />
      <item value="Calculate the initial data with parallel-for jobs." />
      <item value="         We use parallel-for jobs to calculate the initial data for the&#10;         components in the instanced entities. The primary motivation of this&#10;         is to optimize the vector math operations with Burst -- We don't&#10;         expect that parallelism gives a big performance boost." />
      <item value="Jobified initializer" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="315" />
        <entry key="ENGLISH" value="316" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1663166380643" />
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Sarasa Mono SC" />
    <option name="primaryFontFamily" value="Sarasa Mono SC" />
    <option name="showReplacementActionInContextMenu" value="true" />
  </component>
</application>